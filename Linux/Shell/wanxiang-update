#!/usr/bin/env bash

set -euo pipefail

#### é…ç½® Rime éƒ¨ç½²ç›®å½• ####
# æ”¯æŒç›¸å¯¹è·¯å¾„ã€ç»å¯¹è·¯å¾„ã€æ‹“å±•å˜é‡
# ä¾‹å¦‚ "/home/user/.local/share/fcitx5/rime"
# ä¾‹å¦‚ "$HOME/.local/share/fcitx5/rime"
# ä¾‹å¦‚ "${XDG_DATA_HOME:-$HOME/.local/share}/fcitx5/rime"

DEPLOY_DIR=""

######### é…ç½®ç»“æŸ #########

# ç¼“å­˜æ–‡ä»¶
TEMP_DIR=$(mktemp -d)
readonly DEPLOY_DIR TEMP_DIR

# å·¥å…·ç›¸å…³
TOOLS_DIR="$DEPLOY_DIR/update_tools_config"
CONFIG_FILE="$TOOLS_DIR/user_config.json"
UPDATE_FILE="$TOOLS_DIR/update_info.json"
RAW_DIR="$TOOLS_DIR/raw"
UPDATE_TOOLS_REPO="expoli/rime-wanxiang-update-tools"
UPDATE_TOOLS_VERSION="DEFAULT_UPDATE_TOOLS_VERSION_TAG"
readonly CONFIG_FILE UPDATE_FILE RAW_DIR UPDATE_TOOLS_REPO UPDATE_TOOLS_VERSION

# ä»“åº“ä¿¡æ¯
SCHEMA_REPO="amzxyz/rime_wanxiang"
GRAM_REPO="amzxyz/RIME-LMDG"
GH_API="https://api.github.com/repos"
GH_DL="https://github.com"
readonly SCHEMA_REPO GRAM_REPO GH_API GH_DL

# æ—¥å¿—å½©è‰²è¾“å‡º
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
NC="\033[0m"
readonly RED GREEN YELLOW NC

# æ—¥å¿—å‡½æ•°
log() {
  local level="$1" color="$NC"
  case "$level" in
  INFO) color="$GREEN" ;;
  WARN) color="$YELLOW" ;;
  ERROR) color="$RED" ;;
  esac
  shift
  printf "${color}[%s] %s${NC}\n" "$level" "$*"
}
# é”™è¯¯å¤„ç†å‡½æ•°
error_exit() {
  log ERROR "$*"
  cleanup
  exit 1
}
# æ¸…ç†ä¸´æ—¶æ–‡ä»¶
cleanup() {
  if [[ -d "$TEMP_DIR" ]]; then
    rm -rf "$TEMP_DIR" || log WARN "æ¸…ç†ç¼“å­˜æ–‡ä»¶å¤±è´¥"
  fi
}
# æ£€æŸ¥å¿…è¦ä¾èµ–
check_deps() {
  for _cmd in curl unzip jq sha256sum; do
    command -v "$_cmd" >/dev/null || error_exit "ç¼ºå°‘å¿…è¦ä¾èµ–ï¼š$_cmd"
  done
}
# è·å– GitHub API å“åº”å¹¶ç¼“å­˜
get_github_response() {
  local type="$1" url
  case "$type" in
  tools) url="$GH_API/$UPDATE_TOOLS_REPO/releases" ;;
  schema) url="$GH_API/$SCHEMA_REPO/releases" ;;
  dict) url="$GH_API/$SCHEMA_REPO/releases" ;;
  gram) url="$GH_API/$GRAM_REPO/releases" ;;
  esac
  curl -sL --connect-timeout 5 "$url" >"$TEMP_DIR/${type}_response.json" ||
    error_exit "GitHub API å“åº”é”™è¯¯"
}
# è·å–æœ€æ–°ç‰ˆæœ¬å·
get_latest_version() {
  local type="$1" version
  version=$(jq -r '.[].tag_name' "$TEMP_DIR/${type}_response.json" |
    grep -vE "rc|beta|dict-nightly" | sort -Vr | head -n 1)
  echo "$version"
}
# è„šæœ¬è‡ªæ£€
update_tools_check() {
  if [[ "$UPDATE_TOOLS_VERSION" =~ ^"DEFAULT" ]]; then
    log WARN "ä½ æ­£åœ¨ä½¿ç”¨æºæ–‡ä»¶ï¼"
    log WARN "è¯·ä» $GH_DL/$UPDATE_TOOLS_REPO/releases/latest é¡µé¢ä¸‹è½½æ­£å¼ç‰ˆï¼"
    error_exit "æ“ä½œç»ˆæ­¢"
  fi
  log INFO "å·¥å…·å½“å‰ç‰ˆæœ¬ $UPDATE_TOOLS_VERSION"
  log INFO "æ­£åœ¨æ£€æŸ¥æœ¬å·¥å…·æ˜¯å¦æœ‰æ›´æ–°"
  local local_version remote_version
  get_github_response "tools"
  local_version="$UPDATE_TOOLS_VERSION"
  remote_version=$(get_latest_version "tools")
  if [[ "$remote_version" > "$local_version" ]]; then
    log WARN "æ£€æµ‹åˆ°å·¥å…·æœ€æ–°ç‰ˆæœ¬ä¸º: $remote_version, å»ºè®®æ›´æ–°åç»§ç»­"
    log WARN "ä½ å¯ä»è¯¥é“¾æ¥ä¸‹è½½: $GH_DL/$UPDATE_TOOLS_REPO/releases/tag/$remote_version"
  else
    log INFO "å·¥å…·å·²æ˜¯æœ€æ–°ç‰ˆæœ¬"
  fi
}
# é¦–æ¬¡ä½¿ç”¨é…ç½®
first_config() {
  log INFO "æ‚¨ä¼¼ä¹æ˜¯ç¬¬ä¸€æ¬¡ä½¿ç”¨è¯¥å·¥å…·ï¼Œæ¥ä¸‹æ¥å¼•å¯¼æ‚¨è¿›è¡Œå¿…è¦çš„é…ç½®"
  local input_engine schema_type help_code
  input_engine=("fcitx5" "ibus")
  schema_type=("base" "pro")
  help_code=("flypy" "hanxin" "jdh" "moqi" "tiger" "wubi" "zrm")
  local input schema helpcode confirm
  log INFO "è¯·é€‰æ‹©æ‚¨ä½¿ç”¨çš„è¾“å…¥å¼•æ“"
  PS3="è¯·è¾“å…¥é€‰é¡¹å‰æ•°å­—: "
  select _choice in "${input_engine[@]}"; do
    [[ -n "$_choice" ]] || error_exit "æ— æ•ˆçš„é€‰æ‹©"
    input="$_choice"
    break
  done
  log INFO "è¯·é€‰æ‹©æ‚¨ä½¿ç”¨æ–¹æ¡ˆç±»å‹"
  PS3="è¯·è¾“å…¥é€‰é¡¹å‰æ•°å­—: "
  select _choice in "${schema_type[@]}"; do
    [[ -n "$_choice" ]] || error_exit "æ— æ•ˆçš„é€‰æ‹©"
    schema="$_choice"
    break
  done
  if [[ "$schema" == "pro" ]]; then
    log INFO "è¯·é€‰æ‹©æ‚¨ä½¿ç”¨çš„è¾…åŠ©ç "
    PS3="è¯·è¾“å…¥é€‰é¡¹å‰æ•°å­—: "
    select _choice in "${help_code[@]}"; do
      [[ -n "$_choice" ]] || error_exit "æ— æ•ˆçš„é€‰æ‹©"
      helpcode="$_choice"
      break
    done
  else
    helpcode="base"
  fi
  log INFO "æ‚¨é€‰æ‹©äº†ä»¥ä¸‹æ–¹æ¡ˆç»„åˆ: "
  log INFO "è¾“å…¥å¼•æ“: $input"
  log INFO "æ–¹æ¡ˆç±»å‹: $schema"
  [[ "$schema" == "base" ]] || log INFO "è¾…åŠ©ç   : $helpcode"
  log INFO "éƒ¨ç½²ç›®å½•: $DEPLOY_DIR"
  log INFO "è¿™äº›å†…å®¹æ˜¯å¦æ­£ç¡®ï¼Ÿ"
  read -rp "è¯·è¾“å…¥ YES æˆ– NO (åŒºåˆ†å¤§å°å†™): " confirm
  [[ "$confirm" == "YES" ]] || error_exit "ç”¨æˆ·ç»ˆæ­¢æ“ä½œ"
  mkdir -p "$TOOLS_DIR" || error_exit "ä½ æ²¡æœ‰éƒ¨ç½²ç›®å½•çš„è®¿é—®æƒé™ï¼"
  mkdir -p "$RAW_DIR" || error_exit "ä½ æ²¡æœ‰éƒ¨ç½²ç›®å½•çš„è®¿é—®æƒé™ï¼"
  echo -e "{
  \"input\": \"$input\",\n  \"schema\": \"${schema}\",
  \"helpcode\": \"$helpcode\",\n  \"deploy_dir\": \"$DEPLOY_DIR\",
  \"exclude_file\": []\n}" >"$CONFIG_FILE"
  echo -e "{
  \"version\": \"null\",
  \"schema\": {\n    \"name\": \"null\",\n    \"sha256\": \"null\",
    \"update\": \"1970-01-01T00:00:00Z\",\n    \"url\": \"null\"\n  },
  \"dict\": {\n    \"name\": \"null\",\n    \"sha256\": \"null\",
    \"update\": \"1970-01-01T00:00:00Z\",\n    \"url\": \"null\"\n  },
  \"gram\": {\n    \"name\": \"null\",\n    \"sha256\": \"null\",
    \"update\": \"1970-01-01T00:00:00Z\",\n    \"url\": \"null\"\n  }\n}" >"$UPDATE_FILE"
  add_exclude_file
}
add_exclude_file() {
  log INFO "æ¥ä¸‹æ¥å°†æ·»åŠ æ›´æ–°æ—¶éœ€è¦ä¿ç•™çš„å†…å®¹"
  log INFO "è¯·è¾“å…¥éœ€è¦ä¿ç•™çš„æ–‡ä»¶/ç›®å½•çš„ç›¸å¯¹è·¯å¾„"
  log INFO "ä¾‹å¦‚ä½ æƒ³è¦ä¿ç•™éƒ¨ç½²ç›®å½•ä¸‹çš„ \"wanxiang.custom.yaml\""
  log INFO "è¯¥æ–‡ä»¶å®Œæ•´è·¯å¾„ä¸º: $DEPLOY_DIR/wanxiang.custom.yaml"
  log INFO "é‚£ä¹ˆä½ åªéœ€è¦è¾“å…¥ \"wanxiang.custom.yaml\" å³å¯"
  log INFO "æ¯æ¬¡åªå¯ä»¥è¾“å…¥ä¸€ä¸ªæ–‡ä»¶æˆ–ç›®å½•"
  log INFO "æˆ‘ä»¬å·²ç»é¢„è®¾äº†ä»¥ä¸‹å†…å®¹ä½œä¸ºæ’é™¤é¡¹"
  log INFO "\"installation.yaml\" \"user.yaml\""
  log INFO "\"*.custom.yaml\" \"*.userdb\""
  log INFO "å…¨éƒ¨è¾“å…¥å®Œæˆåï¼Œè¯·è¾“å…¥ \"DONE\" æ¥ç»“æŸ (åŒºåˆ†å¤§å°å†™)"
  log WARN "è¯·ä»”ç»†é˜…è¯»ä»¥ä¸Šå†…å®¹" && sleep 3
  local newdata newjson exclude_file
  exclude_file=(
    "update_tools_config"
    "installation.yaml"
    "user.yaml"
    ".custom.yaml"
    ".userdb"
  )
  for _newdata in "${exclude_file[@]}"; do
    newjson=$(jq --arg newdata "$_newdata" '.exclude_file += [$newdata]' "$CONFIG_FILE")
    echo "$newjson" >"$CONFIG_FILE"
  done
  while true; do
    read -rp "è¯·è¾“å…¥éœ€è¦æ’é™¤çš„å†…å®¹ (è¾“å…¥ DONE ç»“æŸ): " newdata
    [[ "$newdata" != "DONE" ]] || break
    if [[ -n $newdata ]]; then
      newjson=$(jq --arg newdata "$newdata" '.exclude_file += [$newdata]' "$CONFIG_FILE")
      echo "$newjson" >"$CONFIG_FILE"
      log INFO "å·²æ·»åŠ  $DEPLOY_DIR/$newdata åˆ°ä¿ç•™å†…å®¹"
    fi
  done
  log INFO "ä»¥ä¸‹å†…å®¹ä¸ºæ›´æ–°æ—¶ä¿ç•™å†…å®¹ï¼Œè¿™äº›å†…å®¹æ˜¯å¦æ­£ç¡®ï¼Ÿ"
  jq '.exclude_file[]' "$CONFIG_FILE"
  read -rp "è¯·è¾“å…¥ YES æˆ– NO (åŒºåˆ†å¤§å°å†™): " confirm
  if [[ "$confirm" != "YES" ]]; then
    rm -rf "$TOOLS_DIR"
    error_exit "ç”¨æˆ·ç»ˆæ­¢æ“ä½œ"
  fi
}
new_update_info() {
  local version="$1" helpcode="$2" type="$3" newfile="$4" newdata newjson
  newdata=$(jq -r --arg version "$version" --arg help_code "$helpcode" \
    '.[] | select(.tag_name == $version ) | 
    .assets.[]| select(.name | test($help_code)) |
    { name: .name, sha256: .digest, update: .updated_at, url: .browser_download_url }' \
    "$TEMP_DIR/${type}_response.json")
  newjson=$(jq --arg type "$type" --argjson newdata "$newdata" '.[$type] = $newdata' "$newfile")
  echo "$newjson" >"$newfile"
}
check_update() {
  local helpcode="$1" newfile="$2" deploy_dir="$3"
  local local_data remote_data
  local schemacheck dictcheck gramcheck
  # æ–¹æ¡ˆæ–‡ä»¶
  local_data=$(date -d "$(jq -r '.schema.update' "$UPDATE_FILE")" +%s)
  remote_data=$(date -d "$(jq -r '.schema.update' "$newfile")" +%s)
  if [[ ! "$local_data" < "$remote_data" ]]; then
    log INFO "æ–¹æ¡ˆæ–‡ä»¶ æ— éœ€æ›´æ–°"
    schemacheck="NO"
  else
    download_and_unzip "schema" "$newfile"
    schemacheck="YES"
  fi
  # è¯å…¸æ–‡ä»¶
  local_data=$(date -d "$(jq -r '.dict.update' "$UPDATE_FILE")" +%s)
  remote_data=$(date -d "$(jq -r '.dict.update' "$newfile")" +%s)
  if [[ ! "$local_data" < "$remote_data" ]]; then
    log INFO "è¯å…¸æ–‡ä»¶ æ— éœ€æ›´æ–°"
    dictcheck="NO"
  else
    download_and_unzip "dict" "$newfile"
    dictcheck="YES"
  fi
  # è¯­æ³•æ¨¡å‹
  local_data=$(date -d "$(jq -r '.gram.update' "$UPDATE_FILE")" +%s)
  remote_data=$(date -d "$(jq -r '.gram.update' "$newfile")" +%s)
  if [[ ! "$local_data" < "$remote_data" ]]; then
    log INFO "è¯­æ³•æ¨¡å‹ æ— éœ€æ›´æ–°"
    gramcheck="NO"
  else
    download_and_unzip "gram" "$newfile"
    gramcheck="YES"
  fi
  [[ "$schemacheck" == "NO" && "$dictcheck" == "NO" && "$gramcheck" == "NO" ]] ||
    touch "$TEMP_DIR/needed_update"
}
download_and_unzip() {
  local type="$1" newfile="$2" displayname
  case "$type" in
  schema) displayname="æ–¹æ¡ˆæ–‡ä»¶" ;;
  dict) displayname="è¯å…¸æ–‡ä»¶" ;;
  gram) displayname="è¯­æ³•æ¨¡å‹" ;;
  esac
  log INFO "$displayname éœ€è¦æ›´æ–°ï¼Œæ­£åœ¨ä¸‹è½½æœ€æ–°æ–‡ä»¶"
  mkdir -p "$RAW_DIR"
  local filename filehash fileurl checkhash
  filename=$(jq -r --arg type "$type" '.[$type].name' "$newfile")
  filehash=$(jq -r --arg type "$type" '.[$type].sha256' "$newfile" | awk -F ':' '{print $2}')
  fileurl=$(jq -r --arg type "$type" '.[$type].url' "$newfile")
  if [[ -f "$RAW_DIR/$filename" ]]; then
    checkhash=$(sha256sum "$RAW_DIR/$filename" | awk '{print $1}')
    if [[ "$filehash" != "$checkhash" ]]; then
      rm -r "$RAW_DIR/${filename:?}"
      curl -L --connect-timeout 5 -o "$RAW_DIR/$filename" "$fileurl"
      checkhash=$(sha256sum "$RAW_DIR/$filename" | awk '{print $1}')
      [[ "$filehash" == "$checkhash" ]] || error_exit "æ–‡ä»¶ä¸‹è½½å‡ºé”™ï¼Œè¯·é‡è¯•ï¼"
    else
      log INFO "æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡ä¸‹è½½"
    fi
  else
    curl -L --connect-timeout 5 -o "$RAW_DIR/$filename" "$fileurl"
    checkhash=$(sha256sum "$RAW_DIR/$filename" | awk '{print $1}')
    [[ "$filehash" == "$checkhash" ]] || error_exit "æ–‡ä»¶ä¸‹è½½å‡ºé”™ï¼Œè¯·é‡è¯•ï¼"
  fi
  if [[ "$type" == "schema" ]]; then
    unzip -q "$RAW_DIR/$filename" -d "$TEMP_DIR/$type"
  elif [[ "$type" == "dict" ]]; then
    unzip -q "$RAW_DIR/$filename" -d "$TEMP_DIR"
    mv "$TEMP_DIR"/*dicts "$TEMP_DIR/$type"
  fi
}
update_all_file() {
  local deploy_dir="$1"
  if [[ -d "$TEMP_DIR/schema" ]]; then
    log INFO "æ­£åœ¨æ›´æ–° æ–¹æ¡ˆæ–‡ä»¶"
    rm -rf "$TEMP_DIR/schema"/{ç®€çº¯+.trime.yaml,custom_phrase.txt,squirrel.yaml,weasel.yaml}
    find "$TEMP_DIR/schema" -type f -exec chmod 644 {} +
    local exclude_file line
    while IFS= read -r line; do
      exclude_file+=("$line")
    done < <(jq -r '.exclude_file[]' "$CONFIG_FILE")
    for _file in "${exclude_file[@]}"; do
      cp -rf "$deploy_dir"/*"$_file" "$TEMP_DIR/schema"
    done
    rm -rf "$deploy_dir"
    cp -rf "$TEMP_DIR/schema" "$deploy_dir"
  fi
  if [[ -d "$TEMP_DIR/dict" ]]; then
    log INFO "æ­£åœ¨æ›´æ–° è¯å…¸æ–‡ä»¶"
    cp -rf "$TEMP_DIR/dict"/* "$deploy_dir/dicts"*/
  fi
  log INFO "æ­£åœ¨æ›´æ–° è¯­æ³•æ¨¡å‹"
  cp -rf "$RAW_DIR"/*.gram "$deploy_dir"
}
# ä¸»å‡½æ•°
main() {
  trap cleanup EXIT
  # æ£€æŸ¥æ˜¯å¦ä¸ºrootç”¨æˆ·
  if [[ "$EUID" -eq 0 ]]; then
    error_exit "è¯·ä¸è¦ä½¿ç”¨ root èº«ä»½è¿è¡Œè¯¥å·¥å…·ï¼"
  fi
  # æ£€æŸ¥å¿…è¦çš„ä¾èµ–
  check_deps
  # æ£€æŸ¥ä¸´æ—¶ç›®å½•
  [[ -d "$TEMP_DIR" ]] || error_exit "ä¸´æ—¶ç›®å½•åˆ›å»ºå¤±è´¥"
  # æ¬¢è¿è¯­
  log INFO "æ¬¢è¿ä½¿ç”¨ Rime ä¸‡è±¡è¾“å…¥æ–¹æ¡ˆ æ›´æ–°åŠ©æ‰‹"
  # è„šæœ¬è‡ªæ£€
  update_tools_check
  # åˆ¤æ–­æ˜¯å¦ç¬¬ä¸€æ¬¡ä½¿ç”¨
  [[ -d "$TOOLS_DIR" ]] || first_config
  # è·å–ç”¨æˆ·è®¾ç½®
  local input helpcode deploy_dir
  input=$(jq -r '.input' "$CONFIG_FILE")
  helpcode=$(jq -r '.helpcode' "$CONFIG_FILE")
  deploy_dir=$(jq -r '.deploy_dir' "$CONFIG_FILE")
  # ç¼“å­˜ GitHub API å“åº”
  get_github_response "schema"
  get_github_response "dict"
  get_github_response "gram"
  # æ£€æŸ¥ç‰ˆæœ¬å·
  local local_data remote_data
  local_data=$(jq -r '.version' "$UPDATE_FILE")
  remote_data=$(get_latest_version "schema")
  log INFO "å½“å‰ç‰ˆæœ¬å·ä¸º $local_data, æœ€æ–°ç‰ˆæœ¬å·ä¸º $remote_data"
  [[ ! "$local_data" > "$remote_data" ]] || log INFO "æ­£åœ¨æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°"
  # ç”Ÿæˆæ–°ç‰ˆ update_info
  local newfile newjson
  cp "$UPDATE_FILE" "$TEMP_DIR/new_update_info.json"
  newfile="$TEMP_DIR/new_update_info.json"
  newjson=$(jq --arg newdata "$remote_data" '.version = $newdata' "$newfile")
  echo "$newjson" >"$newfile"
  new_update_info "$remote_data" "$helpcode" "schema" "$newfile"
  new_update_info "dict-nightly" "$helpcode" "dict" "$newfile"
  new_update_info "LTS" "lts" "gram" "$newfile"
  # æ£€æŸ¥æ›´æ–°
  check_update "$helpcode" "$newfile" "$deploy_dir"
  if [[ -f "$TEMP_DIR/needed_update" ]]; then
    log INFO "ä»¥ä¸‹å†…å®¹ä¸ºæ›´æ–°æ—¥å¿—"
    local changelog
    changelog=$(jq --arg version "$remote_data" '.[] |
      select(.tag_name == $version ) | .body' "$TEMP_DIR/schema_response.json")
    echo -e "$changelog" | awk '/ğŸ“ æ›´æ–°æ—¥å¿—/,/---/'
    log INFO "å¼€å§‹æ›´æ–°æ–‡ä»¶"
    update_all_file "$deploy_dir"
    mv "$newfile" "$UPDATE_FILE"
    log INFO "æ›´æ–°å®Œæˆï¼"
    log INFO "å·²è°ƒç”¨ç›¸å…³æŒ‡ä»¤é‡éƒ¨ç½²æ–¹æ¡ˆ, è¯·è€å¿ƒç­‰å¾…éƒ¨ç½²å®Œæˆ"
    if [[ "$input" == "fcitx5" ]]; then
      dbus-send --session --print-reply --dest=org.fcitx.Fcitx5 /controller \
        org.fcitx.Fcitx.Controller1.ReloadAddonConfig string:rime
    elif [[ "$input" == "ibus" ]]; then
      ibus-daemon -drx
    fi
  else
    log INFO "ä½ æ­£åœ¨ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ï¼Œæ— éœ€æ›´æ–°"
  fi
}
# è°ƒç”¨ä¸»å‡½æ•°
main
